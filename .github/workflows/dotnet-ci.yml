name: Continuous Integration â€” .NET

on:          
  workflow_call:
    inputs:
      dotnet_version: 
        description: 'Version of .NET SDK to use'
        required: true
        type: string
      version_to_build:
        description: 'Package version to build'
        required: true
        type: string
      environment:
        description: 'Deployment environment'
        required: true
        type: string

jobs:
  build-version:
    uses: luciopbrito/actions/.github/workflows/dotnet-build_version.yml@main
    with:
      version: ${{ inputs.version_to_build }}
      dotnet-version: ${{ inputs.dotnet_version }}

  set-secrets:
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-latest
    needs: build-version
    outputs:
      ssh_private_key: ${{ steps.export.outputs.SSH_PRIVATE_KEY }}
      ssh_username: ${{ steps.export.outputs.SSH_USERNAME }}
      ssh_host: ${{ steps.export.outputs.SSH_HOST }}
      ssh_port: ${{ steps.export.outputs.SSH_PORT }}
    steps:
      - id: export
        run: |
          echo "SSH_PRIVATE_KEY=${{ secrets.SSH_PRIVATE_KEY }}" >> $GITHUB_OUTPUT
          echo "SSH_USERNAME=${{ secrets.SSH_USERNAME }}" >> $GITHUB_OUTPUT
          echo "SSH_HOST=${{ secrets.SSH_HOST }}" >> $GITHUB_OUTPUT
          echo "SSH_PORT=${{ secrets.SSH_PORT }}" >> $GITHUB_OUTPUT

  save-ssh:
    needs: set-secrets
    uses: luciopbrito/actions/.github/workflows/ssh-save_key.yml@v1.0.0
    secrets:
      SSH_PRIVATE_KEY: ${{ needs.set-secrets.outputs.ssh_private_key }}
      SSH_USERNAME: ${{ needs.set-secrets.outputs.ssh_username }}
      SSH_HOST: ${{ needs.set-secrets.outputs.ssh_host }}
      SSH_PORT: ${{ needs.set-secrets.outputs.ssh_port }}
    
  deploy:
    needs: [save-ssh, build-version]
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-latest
    steps:
      - name: Save repository name as environment variable
        run: echo "REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d '/' -f 2)" >> $GITHUB_ENV

      - name: Save last api build
        run: |
          # SSH into the remote host and check if the folder is empty
          SSH_RESULT=$(ssh -i ${{needs.save-ssh.outputs.ssh-key-path}} -p ${{ secrets.SSH_PORT }} ${{secrets.SSH_USERNAME}}@${{secrets.SSH_HOST}} "ls -A ${{secrets.SSH_DESTINATION}}")
          
          # Check if the SSH command output is empty (meaning folder is empty)
          if [ -z "$SSH_RESULT" ]; then
            echo "The folder is empty. No command will be run."
          else
            echo "The folder contains files. Running command..."
            # Run your command remotely
            ssh -i ${{needs.save-ssh.outputs.ssh-key-path}} -p ${{ secrets.SSH_PORT }} ${{secrets.SSH_USERNAME}}@${{secrets.SSH_HOST}} "rm -rf ${{secrets.SSH_DEST_BACKUP}}* && cp ${{secrets.SSH_DESTINATION}}* ${{secrets.SSH_DEST_BACKUP}}"
          fi

      - name: Download dist artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-version.outputs.version_built }}
          path: ${{env.REPO_NAME}}_${{ github.run_number }}

      - name: Display structure of downloaded files
        run: ls -R ${{env.REPO_NAME}}_${{ github.run_number }}

      - name: Deploy publish folder to vps
        run: |
          # deploy publish folder to vps
          rsync -avz --delete -e "ssh -i ${{needs.save-ssh.outputs.ssh-key-path}} -p ${{ secrets.SSH_PORT }} -o StrictHostKeyChecking=no" ${{env.REPO_NAME}}_${{ github.run_number }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:${{ secrets.SSH_DESTINATION }}  
          
      - name: Restart Web Server 
        run: | 
          # restart webserver
          ssh -i ${{needs.save-ssh.outputs.ssh-key-path}} -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "${{ secrets.SSH_CMD_RESTART_SERVER }}"
          
  clean-up-ssh:
    needs: [deploy, save-ssh]
    uses: luciopbrito/actions/.github/workflows/ssh-clean_up.yml@v1.0.0
    with:
      ssh-key-path: ${{ needs.save-ssh.outputs.ssh-key-path }}